<p align="center">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="assets/img/goro.logo-dark.png">
      <source media="(prefers-color-scheme: light)" srcset="assets/img/goro.logo.png">
      <img alt="Goro" title="Goro" width="200" src="assets/img/goro.logo.png">
    </picture>
</p>

GORO is a tool that creates a neat and easily expandable project layout for your Golang code, including all the essential boilerplate.

## Project Status

⚠️ **Alpha Stage: Work in Progress**

This project is currently in the alpha stage, indicating that it's in the early phases of development. It may contain bugs, undergo frequent changes, and lack certain features. Use it cautiously and feel free to contribute to its improvement. Check the issues for known problems or planned enhancements.

## Why use GORO?

Starting a new Golang project often involves setting up a project layout and defining a solid architecture. GORO, the code generation tool, simplifies this process, allowing you to focus on the core of your project rather than getting bogged down by the initial setup.

### Key Benefits:

- **Rapid Project Kickstart:**
  GORO provides a clean and easily extendable Golang project layout, enabling you to kickstart your project swiftly. Say goodbye to the tedious task of manually structuring your project each time.

- **Consistent Code Architecture:**
  With GORO, maintain a single, consistent approach to your code architecture across projects. This ensures a streamlined development process and facilitates easier collaboration among team members.

- **Time Savings:**
  GORO saves you valuable time by automating the project initialization process. The time spent on setting up a new project with GORO is significantly less than manual implementation, allowing you to dive into your project's core functionalities sooner.

- **Reduced Error Rate:**
  GORO minimizes the chances of errors during project setup. By automating the generation of a clean and organized project structure, GORO reduces the risk of common mistakes, letting you focus on the creative and innovative aspects of your project.

- **Flexibility with Frameworks:**
  GORO is designed to integrate seamlessly with various web frameworks. Whether you prefer a specific framework or want the flexibility to switch between them, GORO provides the adaptability you need.

Give GORO a try and experience a faster, more efficient start to your Golang projects.

## Getting started
To install GORO, run:
```bash
go install github.com/hanagantig/goro@latest
```

## Run an example service
Goro uses yaml configuration for your service modules.
Download an example config [goro.yaml](https://github.com/hanagantig/goro/blob/main/example/testapp/goro.yaml).

After that you can run `init` command with the config:
```bash
goro init --config /path/to/config/goro.yaml
```
You will be prompted for the workir directory. Provide an absolute path for your service root path.

**Voilà!** Your service is ready. You can run and check the `ping` http method generated by default.
Go to your workdir and run command:
```bash
go run . http --config=./config/app.conf.yaml
```

Open in your browser [http://localhost:8095/api/v1/ping](http://localhost:8095/api/v1/ping)
And you can see `pong` for your `ping`.

## Youtube presentation

You can get more details from the Youtube video (in Russian):

[Архитектура Go проекта на практике](https://www.youtube.com/watch?v=hDwqFRUuykQ)

# Layout

![Layout schema](assets/img/layout.png?raw=true "layout")

```
├── api - your api specs (swagger, protobuf etc.)
│   ├── v1 - version and particular specs inside
│   │   └── swagger.yaml
│   │
├── build - folder with docker files, docker-compose files and so on
│   ├── Dockerfile
│   └── ...
├── cmd  - folder with commands provided by your service
│   ├── command_name.go - service command implementation
│   └── ...
├── configs - service config files
│   ├── prod.conf.yaml
│   ├── local.conf.yaml
│   └── dev.conf.yaml
│
├── internal - folder for your internal package. Usually you write code here.
│   ├── app - App structure with bootstrapping, definitions and DI
│   │
│   ├── entity - service entity (they should be used globally through all layers as a data transmitters)
│   │
│   ├── service - list of our services with business logic. This layer interacts with adapter layer.
│   │
│   ├── usecase - usecase layer represent our service behaviour. It's describes all app features - interface for whole service.
│   │                 Use case orchestrate with services and aggregate service methods calls. It can be used only in handler layer.
│   ├── adapter - your infrastructure is here. Adapter folder contains packages for database connection, other http/grpc service clients, AMQP connections etc. ...
│   │   ├── webapi
│   │   ├── sqlrepository
│   │   └── ...
│   ├── config - you can find here a code for parsing and loading service configs
│   └── handler - our handlers - a layer to communicate with client. It describes our transport and request/response models.
│       ├── http - http protocol handler
│       │   ├── http.go - http server implementation
│       │   ├── router.go - base router implementation
│       │   └── api - package for service http API methods
│       │       └── v1
│       │           └── models - request/response methods (usually generated from swagger file)
│       │               ├── handler.go - api methods implementation
│       │               └── router.go  - api methods routing
│       ├── grpc - grpc protocol handlers
│       ├── amqp - amqp protocol handlers
│       └── ...
└── pkg - your public pkgs
```
